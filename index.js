// Production-Ready Backend Server with Agentic Workflow
// This server orchestrates multiple AI agents, handles Figma API integration,
// and generates a complete, runnable React project scaffold.

const express = require('express');
const cors = require('cors');
const multer = require('multer');
const dotenv = require('dotenv');
const { GoogleGenerativeAI } = require('@google/generative-ai');
const axios = require('axios');

dotenv.config();

const app = express();

// --- Middleware Setup ---
const corsOptions = {
  origin: 'https://digital-studio-frontend-new.vercel.app',
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
};
app.use(cors(corsOptions));
app.options('*', cors(corsOptions)); // Pre-flight request handling
app.use(express.json({ limit: '50mb' }));
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

// --- API Initialization ---
const genAI = new GoogleGenerativeAI("AIzaSyA5_KnR58T2MTG4oOvBeAqbd8idJCdOlRA");
const figmaApiToken = process.env.FIGMA_API_TOKEN;
const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

// --- Helper Functions ---
function bufferToGenerativePart(buffer, mimeType) {
  return {
    inlineData: {
      data: buffer.toString("base64"),
      mimeType,
    },
  };
}

function toPascalCase(str) {
    if (typeof str !== 'string' || !str) {
        return `Component${Math.floor(Math.random() * 1000)}`;
    }
    return str
        .replace(/[^a-zA-Z0-9]+/g, ' ') 
        .split(' ')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join('');
}

async function callGenerativeAI(prompt, images = [], generationConfigOptions = {}) {
    const contentParts = [{ text: prompt }, ...images];
    
    const generationConfig = { ...generationConfigOptions };

    const result = await model.generateContent({ 
        contents: [{ role: "user", parts: contentParts }],
        generationConfig
    });
    const response = await result.response;
    let text = response.text();
    
    if (!generationConfig.responseMimeType || generationConfig.responseMimeType !== 'application/json') {
        text = text.replace(/```(json|javascript|jsx)?/g, '').replace(/```/g, '').trim();
    }
    return text;
}

// --- Boilerplate File Content ---
const getProjectFiles = (projectName, generatedFiles) => {
    const allFiles = { ...generatedFiles };

    // UPDATED: package.json to use react-scripts (Create React App)
    allFiles['package.json'] = JSON.stringify({
        name: projectName.toLowerCase().replace(/\s+/g, '-'),
        private: true,
        version: '0.1.0',
        dependencies: {
            '@testing-library/jest-dom': '^5.17.0',
            '@testing-library/react': '^13.4.0',
            '@testing-library/user-event': '^13.5.0',
            'react': '^18.2.0',
            'react-dom': '^18.2.0',
            'react-router-dom': '^6.22.3',
            'react-scripts': '5.0.1',
            'web-vitals': '^2.1.4'
        },
        // FIXED: Added eslint-plugin-react-refresh to devDependencies
        devDependencies: {
            "eslint-plugin-react-refresh": "^0.4.7"
        },
        scripts: {
            start: 'react-scripts start',
            build: 'react-scripts build',
            test: 'react-scripts test',
            eject: 'react-scripts eject'
        },
        eslintConfig: {
            extends: [
                'react-app',
                'react-app/jest'
            ]
        },
        browserslist: {
            production: [
                '>0.2%',
                'not dead',
                'not op_mini all'
            ],
            development: [
                'last 1 chrome version',
                'last 1 firefox version',
                'last 1 safari version'
            ]
        }
    }, null, 2);
    
    // ADDED: tailwind.config.js for Create React App
    allFiles['tailwind.config.js'] = `/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}`;
    
    // ADDED: postcss.config.js for Create React App
    allFiles['postcss.config.js'] = `module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}`;

    allFiles['README.md'] = `# ${projectName}\n\nThis project was generated by VM Digital Studio.\n\n## Available Scripts\n\nIn the project directory, you can run:\n\n### \`npm start\`\n\nRuns the app in the development mode.\nOpen [http://localhost:3000](http://localhost:3000) to view it in your browser.\n\n### \`npm test\`\n\nLaunches the test runner in the interactive watch mode.\n\n### \`npm run build\`\n\nBuilds the app for production to the \`build\` folder.`;
    
    // UPDATED: index.html to match Create React App structure
    allFiles['public/index.html'] = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>${projectName}</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>`;
    
    // ADDED: Basic favicon and manifest for CRA
    allFiles['public/favicon.ico'] = ''; // Placeholder for favicon
    allFiles['public/manifest.json'] = JSON.stringify({
        short_name: projectName,
        name: `VM Digital Studio - ${projectName}`,
        start_url: ".",
        display: "standalone",
        theme_color: "#000000",
        background_color: "#ffffff"
    }, null, 2);


    // UPDATED: src/index.js (was main.jsx) to match Create React App entry point
    allFiles['src/index.js'] = `import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import { BrowserRouter } from 'react-router-dom';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();
`;

    // UPDATED: src/index.css to include Tailwind directives
    allFiles['src/index.css'] = `@tailwind base;
@tailwind components;
@tailwind utilities;`;

    // ADDED: reportWebVitals.js for CRA
    allFiles['src/reportWebVitals.js'] = `const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;
`;

    return allFiles;
}

// --- API Routes ---

app.get('/', (req, res) => {
    res.status(200).json({ message: 'Digital Studio backend is running!' });
});

app.get('/api', (req, res) => {
    res.send('Backend server is running!');
});

app.post('/api/import-figma', async (req, res) => {
    const { figmaUrl } = req.body;
    if (!figmaUrl) {
        return res.status(400).json({ error: 'Figma URL is required.' });
    }
    if (!figmaApiToken) {
        return res.status(500).json({ error: 'Figma API token is not configured on the server.' });
    }

    try {
        const fileKeyMatch = figmaUrl.match(/file\/([a-zA-Z0-9]+)/);
        if (!fileKeyMatch || !fileKeyMatch[1]) {
            return res.status(400).json({ error: 'Invalid Figma URL format. Could not extract file key.' });
        }
        const fileKey = fileKeyMatch[1];

        console.log(`Fetching Figma file with key: ${fileKey}`);
        const figmaFileResponse = await axios.get(`https://api.figma.com/v1/files/${fileKey}`, {
            headers: { 'X-Figma-Token': figmaApiToken }
        });

        const canvas = figmaFileResponse.data.document.children.find(c => c.type === 'CANVAS');
        if (!canvas) {
             return res.status(404).json({ error: 'No canvas found on the first page of the Figma file.' });
        }

        const frameIds = canvas.children.filter(c => c.type === 'FRAME').map(c => c.id);

        if (frameIds.length === 0) {
            return res.status(404).json({ error: 'No frames found on the first page of the Figma file.' });
        }

        console.log(`Found ${frameIds.length} frames. Fetching images...`);
        const figmaImagesResponse = await axios.get(`https://api.figma.com/v1/images/${fileKey}?ids=${frameIds.join(',')}&format=png`, {
            headers: { 'X-Figma-Token': figmaApiToken }
        });
        
        const imageUrls = figmaImagesResponse.data.images;
        const frameNames = canvas.children.filter(c => c.type === 'FRAME').map(c => ({id: c.id, name: c.name}));
        
        const result = frameNames.map(frame => ({
            fileName: `${frame.name}.png`,
            imageUrl: imageUrls[frame.id]
        }));

        res.json(result);

    } catch (error) {
        console.error('Error fetching from Figma API:', error.response ? error.response.data : error.message);
        res.status(500).json({ error: 'Failed to fetch data from Figma API. Check server logs for details.' });
    }
});


app.post('/api/generate-code', upload.array('screens'), async (req, res) => {
    console.log('Received request to /api/generate-code');

    try {
        const { projectName = 'react-project' } = req.body;
        const screenFiles = req.files;
        if (!screenFiles || screenFiles.length === 0) {
            return res.status(400).json({ error: 'No screen images provided.' });
        }

        const imageParts = screenFiles.map(file => bufferToGenerativePart(file.buffer, file.mimetype));
        let generatedFiles = {};

        // === Step 1: Architect Agent ===
        console.log("Agent [Architect]: Analyzing project structure from images...");
        const architectPrompt = `You are an expert software architect. Analyze these UI screens holistically. Your task is to identify all distinct pages and all common, reusable components (like navbars, buttons, cards, footers, etc.). Provide your output as a single JSON object with two keys: "pages" and "reusable_components". IMPORTANT: All names must be in PascalCase.`;
        
        let plan;
        let planJson;
        try {
            planJson = await callGenerativeAI(architectPrompt, imageParts, { responseMimeType: "application/json" });
            plan = JSON.parse(planJson);
        } catch (e) {
            console.error("Fatal: Failed to parse JSON from Architect Agent.", e);
            console.error("Architect Agent raw response:", planJson);
            throw new Error("Architect Agent failed to produce valid JSON. Cannot continue.");
        }
        
        // ADDED: Defensive checks to prevent crashes on malformed AI response.
        plan.pages = Array.isArray(plan.pages) ? plan.pages.map(toPascalCase) : [];
        plan.reusable_components = Array.isArray(plan.reusable_components) ? plan.reusable_components.map(toPascalCase) : [];

        console.log("Agent [Architect]: Plan created:", plan);

        // === Step 2: Component Builder Agent (BATCHED) ===
        console.log("Agent [Component Builder]: Building reusable components in a single batch...");
        const componentNames = plan.reusable_components;
        if (componentNames.length > 0) {
            // FIXED: Updated prompt to explicitly require a default export.
            const componentBuilderPrompt = `Based on the provided UI screens, generate the React JSX code for all of the following reusable components: ${componentNames.join(', ')}.
Your response MUST be a single JSON object.
The keys of the object should be the component names in PascalCase (e.g., "Header", "Footer").
The values should be the complete, raw JSX code for each corresponding component as a string.
The components should be functional, use Tailwind CSS, and be highly reusable.
IMPORTANT: Each component's code MUST end with a default export statement, for example: 'export default ComponentName;'`;

            const properties = {};
            componentNames.forEach(name => {
                properties[name] = { type: "STRING" };
            });

            const componentSchema = {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "OBJECT",
                    properties: properties,
                },
            };

            let components;
            let componentsJson;
            try {
                componentsJson = await callGenerativeAI(componentBuilderPrompt, imageParts, componentSchema);
                components = JSON.parse(componentsJson);
            } catch (e) {
                console.error("Fatal: Failed to parse JSON from Component Builder Agent.", e);
                console.error("Component Builder Agent raw response:", componentsJson);
                throw new Error("Component Builder Agent failed to produce valid JSON. Cannot continue.");
            }

            for (const componentName in components) {
                const code = components[componentName];
                generatedFiles[`src/components/${componentName}.jsx`] = code;
                console.log(` -> Built: ${componentName}`);
            }
        }

        // === Step 3: Page Composer Agent ===
        console.log("Agent [Page Composer]: Building pages...");
        for (let i = 0; i < plan.pages.length; i++) {
            const pageName = plan.pages[i];
            console.log(` -> Building: ${pageName}`);
            const importStatements = plan.reusable_components.map(comp => `import ${comp} from '../components/${comp}';`).join('\n');
            const pagePrompt = `Generate the React JSX code for the page named "${pageName}", based on the corresponding screen design. You must import and use the available reusable components where appropriate.\n${importStatements}\nThe page should be functional, use Tailwind CSS, and correctly import components from '../components/'. Do not include any explanations, just the raw JSX code.`;
            const pageCode = await callGenerativeAI(pagePrompt, [imageParts[i]]);
            generatedFiles[`src/pages/${pageName}.jsx`] = pageCode;
        }

        // === Step 4: Finisher Agent ===
        // ADDED: Graceful handling for cases where no pages are identified.
        if (plan.pages.length > 0) {
            console.log("Agent [Finisher]: Assembling the application...");
            const finisherPrompt = `You are an expert React developer. Create the main App.jsx component that sets up routing for the following pages using react-router-dom. You MUST import the page components using these exact names and paths:\n${plan.pages.map(p => `- import ${p} from './pages/${p}';`).join('\n')}\nCreate a simple navigation bar with a NavLink for each page. The first page, "${plan.pages[0]}", should be the home route ('/'). Do not include any explanations, just the raw JSX code.`;
            const appRouterCode = await callGenerativeAI(finisherPrompt);
            generatedFiles['src/App.jsx'] = appRouterCode;
        } else {
            console.log("Agent [Finisher]: No pages found, creating a fallback App.jsx.");
            generatedFiles['src/App.jsx'] = `import React from 'react';\n\nfunction App() {\n  return (\n    <div style={{ padding: '2rem', textAlign: 'center' }}>\n      <h1>Code Generation Incomplete</h1>\n      <p>The AI architect did not identify any pages from the provided images. Please try again with different images.</p>\n    </div>\n  );\n}\n\nexport default App;`;
        }
        
        // === Step 5: QA Reviewer Agent ===
        // ADDED: Skip QA if no pages exist to be reviewed.
        let accuracyResult = { score: 0, justification: "Skipped; no pages were generated to review." };
        if (plan.pages.length > 0) {
            console.log("Agent [QA Reviewer]: Performing quality check...");
            let accuracyResultJson;
            try {
                const qaSchema = {
                    responseMimeType: "application/json",
                    responseSchema: {
                        type: "OBJECT",
                        properties: {
                            score: { type: "NUMBER" },
                            justification: { type: "STRING" },
                        },
                    },
                };
                const accuracyPrompt = `You are a UI/UX quality assurance expert. Compare the provided user interface image with the generated React code. Based on your analysis of layout, color, typography, and component structure, provide a percentage score representing the accuracy of the code. Also, provide a brief one-sentence justification for your score. Respond only in JSON format with the keys "score" (a number) and "justification" (a string).`;
                accuracyResultJson = await callGenerativeAI(accuracyPrompt, [imageParts[0]], qaSchema);
                accuracyResult = JSON.parse(accuracyResultJson);
                console.log("Agent [QA Reviewer]: Accuracy score calculated:", accuracyResult);
            } catch (e) {
                console.error("Non-fatal: Failed to parse JSON from QA Reviewer Agent.", e);
                console.error("QA Reviewer Agent raw response:", accuracyResultJson);
                accuracyResult = { score: 0, justification: "Accuracy could not be determined due to a response parsing error." };
            }
        } else {
             console.log("Agent [QA Reviewer]: No pages found, skipping quality check.");
        }
        
        // === Final Step: Add Boilerplate Files ===
        const finalProjectFiles = getProjectFiles(projectName, generatedFiles);

        console.log("Agentic workflow complete. Sending code to frontend.");
        res.json({ generatedFiles: finalProjectFiles, accuracyResult });

    } catch (error) {
        console.error('Error during agentic code generation:', error.message);
        res.status(500).json({ error: 'An error occurred on the server during code generation. Check server logs for details.' });
    }
});

// Export the app for Vercel
module.exports = app;
